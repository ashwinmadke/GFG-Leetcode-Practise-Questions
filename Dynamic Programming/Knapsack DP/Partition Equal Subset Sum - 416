// https://leetcode.com/problems/partition-equal-subset-sum/

// Recursive Approach (Brute Force)
// TC - O(2^n)
// SC - O(n) // recursive stack space

public boolean canPartition(int[] nums) {
        int n = nums.length;
        int totSum = 0;

        for(int i : nums) // calculate whole array elements sum
        totSum += i;

        if(totSum % 2 != 0) return false; // if totSum is odd means we can't divide array

        int target = totSum/2;

        return subsetSum(nums,n-1, target);
    }
    private static boolean subsetSum(int[] arr, int i, int target){
        // base case
        if(target == 0) return true; // means we found 1 valid subset

        if(i < 0 || target < 0) return false; // if index out of bound or target is -ve return false
   
        boolean include = subsetSum(arr, i-1, target - arr[i]); //include
        boolean exclude = subsetSum(arr,i-1, target);  //exclude

        return include || exclude;
    }

// Top Down Approach :
// TC - (n * target)
// SC - (n * target)

public boolean canPartition(int[] nums) {
        int n = nums.length;
        int tot_sum = 0;
        for(int i : nums){
            tot_sum += i;
        }
        
        if(tot_sum %2 != 0){
            return false;
        }
        
        int target = tot_sum / 2;
        int[][] dp = new int[n+1][target+1];
        for(int[] row : dp){
            Arrays.fill(row,-1);
        }
        return subsetSum(nums,target, n-1, dp);
    }
    static boolean subsetSum(int[] nums, int sum, int idx, int[][] dp){
        int n = nums.length;
        if(sum == 0) return true;
        
        if(idx < 0 || sum < 0) return false;
        
        // if already calculated
        if(dp[idx][sum] != -1){
            return dp[idx][sum] == 1;
        }
        
         // Include current element in subset or skip it
        
        boolean include = subsetSum(nums, sum - nums[idx], idx-1, dp);    
        boolean exclude = subsetSum(nums, sum, idx-1,dp);
        
        // store the result & return
        dp[idx][sum] = (include || exclude) ? 1 : 0;
        return dp[idx][sum] == 1;
    }
