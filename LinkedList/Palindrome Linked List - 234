// https://leetcode.com/problems/palindrome-linked-list/

*********************************************************************************************************************************************************************
Brute Approach 1 - Using List/array
Idea:
Traverse the linked list and copy all node values into an array/list.
Use two pointers approach, one at start and one at the end of the array, and compare values.
If all match means palindrome, else not palindrome.
TC: O(n) — for traversing + comparing
SC: O(n) for the list/array

*********************************************************************************************************************************************************************
Brute Approach 2- Using Stack
Idea - 
1.Find the middle of the list.
2.Traverse from head to middle, pushing node values onto a stack.
3.From middle to end, compare each node’s value with the top of the stack.
4.If all values match → palindrome, else → not palindrome.

TC: O(n) — two passes (one to middle, one to compare)
SC: O(n/2) → O(n) for the stack

*********************************************************************************************************************************************************************
Optimal Approach -
Idea:
1.Find the middle of the list using slow & fast pointers.
2.Reverse the second half of the list.
3.Use two pointers: one starting at head, one at the head of the reversed second half.
4.Compare values node by node. If all match → palindrome, else → not palindrome.

TC: O(n) — single pass to find middle + reverse + compare
SC: O(1) —  no extra space

public boolean isPalindrome(ListNode head) {
        //step 1:  find mid 
        ListNode slow = head;
        ListNode fast = head;

        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        // Step 2 : reverse second half
        ListNode curr = slow; // mid -> slow
        ListNode prev = null;

        while(curr != null){
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        // Step 3: compare both list
        ListNode first = head; // original 
        ListNode second = prev; // prev ->new head of reverse list

        while(second != null){
            if(first.val != second.val) return false;
            first = first.next;
            second = second.next;
        }
        return true;
    }
