// https://leetcode.com/problems/longest-repeating-character-replacement/

********************************************************************************************************************************************************************
Brute Approach - 
Idea - Check all substrings, count max repeating char, see if replacements â‰¤ k, track max length.
TC - O(n^2)
SC - O(1)

public int characterReplacement(String s, int k) {
        int n = s.length();
        int maxSubstringLen = 0;

        //Step 1: Check all substrings
        for (int i = 0; i < n; i++) {

            //Step 2: count max repeating char
            int[] count = new int[26];
            int maxFreq = 0; // max freq in current substring

            for (int j = i; j < n; j++) {
                char currChar = s.charAt(j);
                count[currChar - 'A']++; //increment frequency of current character
                maxFreq = Math.max(maxFreq, count[currChar - 'A']); // update max frequency

                int currWindowLen = j - i + 1;
                int replacementNeeded = currWindowLen - maxFreq;

                if (replacementNeeded <= k) {
                    maxSubstringLen = Math.max(maxSubstringLen, currWindowLen);
                }
            }

        }
        return maxSubstringLen;
    }


********************************************************************************************************************************************************************

TC - O(n)
SC - O(1)
Idea - Use the sliding window method with two pointers (left and right). As you move the right pointer, update the frequency array to count characters and track the most frequent one. 
If the characters to change (window size - max frequency) are more than k, move the left pointer to shrink the window. 
Keep updating the maximum window size and return it in the end.

public int characterReplacement(String s, int k) {
        int maxLen = 0;
        int maxFreq = 0;
        int start = 0; // window ka start pointer
        int[] count = new int[26]; // A-Z characters ka frequency count ke liye

        for (int end = 0; end < s.length(); end++) {

            // curr character ka count update karo
            int idx = s.charAt(end) - 'A';
            count[idx]++;

            // update max frequency -> windowSize me sabse jyda repeat hone wala character
            maxFreq = Math.max(maxFreq, count[idx]);

            int windowLen = end - start + 1;
            int changesNeeded = windowLen - maxFreq;

            // shrink window if needed
            if (changesNeeded > k) {
                count[s.charAt(start) - 'A']--;
                start++;
                windowLen = end - start + 1; // update windowLen after shrinking
            }
            // update maxLen every time
            maxLen = Math.max(maxLen, windowLen);
        }
        return maxLen;
    }
