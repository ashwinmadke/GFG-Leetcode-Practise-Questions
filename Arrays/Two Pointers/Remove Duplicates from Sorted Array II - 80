// https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/

***********************************************************************************************************************************************************
Brute Approach - Using temp array
Idea - Take temp array, while iterating over original array keep track of each element, if its <=2 add into temp else make count = 1 repeat same untill all 
processed. in the end copy back element to original array and return temp size as k.
// TC-> O(n)
// SC-> O(n)

public int removeDuplicates(int[] nums) {
        List<Integer> temp = new ArrayList<>();

        int count = 1;
        temp.add(nums[0]);

        for(int i=1; i<nums.length; i++){
            if(nums[i] == nums[i-1]){
                count++;
            }
            else{
                count = 1;
            }

            if(count <= 2){
                temp.add(nums[i]);
            }
        }
        //copy back to nums
        for(int i=0; i<temp.size(); i++){
            nums[i] = temp.get(i);
        }

        return temp.size();
    }




***********************************************************************************************************************************************************
Optimal Approach - Using Two Pointers
TC - O(n)
SC - O(1)

public int removeDuplicates(int[] nums) {
        int n = nums.length;
        if(n < 3) return n; // agr array ki len 3 se choti hai to return kardo

        int i=2; // next element kha aayega btayega
        for(int j=2; j<n; j++){
            if(nums[j] != nums[i-2]){
                nums[i] = nums[j];
                i++;
            }
        }
        return i; // new length

    }
