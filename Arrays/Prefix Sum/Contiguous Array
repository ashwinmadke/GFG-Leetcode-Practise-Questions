// https://leetcode.com/problems/contiguous-array/description/

*******************************************************************************************************************************************************************
Brute Approach
Idea - Iterate over all possible sub-arrays and count no of 0's & 1's in each sub-array. If the count is equal update the maximum length.
TC - O(n^2)
SC - O(1)

public int findMaxLength(int[] nums) {
        int n = nums.length;
        int maxLen = 0;

        for(int i=0; i<n; i++){
            int count_0 = 0;
            int count_1 = 0;
            for(int j=i; j<n; j++){
                if(nums[j] == 0){
                    count_0++;
                }
                else{
                    count_1++;
                }
                if(count_0 == count_1){
                    maxLen = Math.max(maxLen, j-i+1);
                }
            }
        }
        return maxLen;  
    }
*******************************************************************************************************************************************************************
TC - O(n^2)
SC - O(1)


Idea - Computes prefix sum for every new subarray 
Array me 0 aane pe use -1 me convert krdo and ek prefix sum array maintain karo, yadi same sum dusre index pe bhi aata hai mtlab unke bich ke elements valid subarray form kar rhe hai.
public int findMaxLength(int[] nums) {
    int n = nums.length;
    int[] prefixSum = new int[n + 1];
    
    // Convert 0s to -1s s
    for (int i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + (nums[i] == 0 ? -1 : 1);
    }
    
    int maxLen = 0;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j <= n; j++) {
            if (prefixSum[i] == prefixSum[j]) {
                maxLen = Math.max(maxLen, j - i);
            }
        }
    }
    return maxLen;
}

*******************************************************************************************************************************************************************
Optimal Approach - Use Map + Prefix sum
Idea - 
Use hashmap for tracking sum and index, initially (0,-1)
make element of array 0 to -1 and 1 to +1,
check if sum is already in map, update max len - map.get(sum)
else put into map
KeyPoint- Change 0 to -1 so that 0s and 1s balance to sum 0.

TC - O(n)
SC - O(n)

    public int findMaxLength(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0,-1);

        int maxLen=0;
        int prefixSum = 0;

        for(int i=0; i<nums.length; i++){
            prefixSum +=(nums[i] == 0) ? -1 : 1;

            if(map.containsKey(prefixSum)){
                maxLen = Math.max(maxLen, i - map.get(prefixSum));
            }
            else{
                map.put(prefixSum, i);
            }
        }
        return maxLen;
        
    }
