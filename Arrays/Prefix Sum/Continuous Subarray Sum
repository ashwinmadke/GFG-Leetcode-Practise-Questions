// https://leetcode.com/problems/continuous-subarray-sum/description/

********************************************************************************************************************************************************************
Brute Approach - Nested loop
Idea - Generate all subarray of length >= 2, for each subarray check if its (sum % k == 0), if yes return true, otherwise false.
TC - O(n^2)
SC - O(1)

public boolean checkSubarraySum(int[] nums, int k) {
        int n = nums.length;
        for(int i=0; i<n; i++){
            int prefixSum = nums[i];
            for(int j=i+1; j<n; j++){
                prefixSum += nums[j];
                if(prefixSum % k == 0){
                    return true;
                }
            }
        }
        return false;
  }

********************************************************************************************************************************************************************
Optimal Approach - PrefixSum + HashMap
Idea - 
Use a map to store remainder → first index, initially (0, -1). Keep running sum while iterating.
For each sum, check remainder % k: if already in map and subarray length ≥ 2 → return true; else store first occurrence.
Return false if no valid subarray found.

TC - O(n)
SC - O(n)

public boolean checkSubarraySum(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0,-1); // corner case

        int prefixSum = 0;
        for(int i=0; i<nums.length; i++){
            prefixSum += nums[i];
            int reminder = prefixSum % k;

            // to handle negative we can write like this as well
            // int reminder = ((prefixSum % k)+k)% k;

            if(map.containsKey(reminder)){
                //check length 
                if(i- map.get(reminder) > 1){
                    return true;
                }
            }
            else{
                map.put(reminder, i); // first time hai to map me dal do
            }

        }
        return false;
    }
